# Untitled notebook

```elixir
Mix.install(
  [
    {:nx, "~> 0.7.1"},
    {:exla, "~> 0.7.1"},
    {:number, "~> 1.0.4"}
  ],
  config: [
    nx: [default_backend: EXLA.Backend]
  ],
  system_env: [
    XLA_TARGET: "cuda120"
  ]
)
```

## Section

To compile EXLA for CUDA, set env var: **`XLA_TARGET="cuda120"`**, that's all.
When running, EXLA will look for available clients in this order: cuda, rocm, tpu, host. So cuda will be prioritised, there's no need to set it as default.

https://hexdocs.pm/exla/EXLA.html#module-configuration

```elixir
Nx.global_default_backend({EXLA.Backend, client: :cuda})

n = 1000
iters = 100
shape = {n, n}
key = Nx.Random.key(2137)
{t1, key} = Nx.Random.uniform(key, shape: shape)
{t2, _key} = Nx.Random.uniform(key, shape: shape)

calculation = fn ->
  0..(iters - 1)
  |> Enum.map(fn _ ->
    Nx.dot(t1, t2)
    |> Nx.sum(axes: [0, 1])
  end)
end

{time, res} = :timer.tc(calculation, [])
res |> Enum.at(iters - 1) |> IO.inspect()
~s/#{(time / 1000 / iters) |> Number.Delimit.number_to_delimited()} ms\/iter/ |> IO.puts()
```

```elixir
import Nx.Defn

# Note: now works for ints only
defmodule CoralReef do
  defstruct fitness_fn: nil,
            iters: nil,
            dim: nil,
            domain: nil,
            mutation_range: nil,
            settling_trials: nil,
            n_broadcast: nil,
            n_duplication: nil,
            prob_die: nil

  @type t :: %__MODULE__{
          dim: integer,
          domain: {number, number},
          mutation_range: {number, number},
          settling_trials: integer,
          n_broadcast: float,
          n_duplication: float,
          prob_die: float
        }

  def new(
        key,
        fitness_fn,
        dim,
        domain,
        mutation_range,
        n_corals \\ 100,
        settling_trials \\ 10,
        frac_init_alive \\ 0.6,
        frac_broadcast \\ 0.5,
        frac_duplication \\ 0.1,
        prob_die \\ 0.5
      ) do
    grid_values = Nx.broadcast(0, {n_corals, dim})
    grid_alive = Nx.broadcast(0, {n_corals})

    key = Nx.Random.key(key)
    n_alive = trunc(frac_init_alive * n_corals)

    {alive_ind, key} =
      Nx.Random.choice(key, Nx.iota({n_corals}), replace: false, samples: n_alive)

    alive_ind = Nx.reshape(alive_ind, {:auto, 1})

    {values, key} =
      Nx.Random.randint(key, elem(domain, 0), elem(domain, 1) + 1, shape: {n_alive, dim})

    grid_values = Nx.indexed_put(grid_values, alive_ind, values)
    grid_alive = Nx.indexed_put(grid_alive, alive_ind, Nx.broadcast(1, {n_alive}))

    {
      key,
      grid_values,
      grid_alive,
      %CoralReef{
        fitness_fn: fitness_fn,
        dim: dim,
        domain: domain,
        mutation_range: mutation_range,
        settling_trials: settling_trials,
        n_broadcast: ((frac_broadcast * n_corals) |> trunc() |> div(2)) * 2,
        n_duplication: trunc(frac_duplication * n_corals),
        prob_die: prob_die
      }
    }
  end

  defn crossover(key, t) do
    n_crossover_points = t |> Nx.shape() |> elem(0) |> div(2)
    dim = Nx.shape(t) |> elem(1)

    {crossover_points, key} =
      Nx.Random.randint(key, 0, dim, shape: {n_crossover_points})

    crossover_points =
      crossover_points
      |> Nx.reshape({:auto, 1})
      |> Nx.broadcast({n_crossover_points, 2})
      |> Nx.reshape({:auto, 1})
      |> Nx.broadcast(Nx.shape(t))

    t_swap =
      t
      |> Nx.reshape({:auto, 2, dim})
      |> Nx.reverse(axes: [1])
      |> Nx.reshape({:auto, dim})

    indexing = Nx.iota(t |> Nx.shape(), axis: 1)

    {
      key,
      Nx.select(Nx.less(indexing, crossover_points), t, t_swap)
    }
  end

  defn bit_flip(key, t) do
    {flip?, key} = Nx.Random.uniform(key, shape: Nx.shape(t))
    {key, Nx.select(flip? < 0.5, t, 1 - t)}
  end

  # t: {n, dim}, mask: {n}
  defn shuffle_together(key, t, mask) do
    mask = Nx.reshape(mask, {:auto, 1}) |> Nx.broadcast(Nx.shape(t))
    zipped = Nx.stack([t, mask])
    {zipped, key} = Nx.Random.shuffle(key, zipped, axis: 1)
    {t, mask} = zipped |> Nx.split(1, axis: 0)
    t = t[0]
    mask = mask[0] |> Nx.slice([0, 0], [elem(Nx.shape(mask), 1), 1]) |> Nx.flatten()
    {key, t, mask}
  end

  defn larvae_settling(key, grid_values, grid_alive, larvae, ops \\ []) do
    settling_trials = ops[:settling_trials]
    fitness_fn = ops[:fitness_fn]

    n_larvae = Nx.shape(larvae) |> elem(0)
    n_corals = grid_values |> Nx.shape() |> elem(0)

    {larvae, to_settle} =
      if n_larvae < n_corals do
        {
          Nx.concatenate([
            larvae,
            0 |> Nx.broadcast({n_corals - n_larvae, larvae |> Nx.shape() |> elem(1)})
          ]),
          Nx.concatenate([
            1 |> Nx.broadcast({n_larvae}),
            0 |> Nx.broadcast({n_corals - n_larvae})
          ])
        }
      else
        {
          larvae,
          1 |> Nx.broadcast({n_corals})
        }
      end

    {key, grid_values, grid_alive, _larvae, _to_settle, _i} =
      while {key, grid_values, grid_alive, larvae, to_settle, i = 0},
            i < settling_trials and to_settle |> Nx.sum() |> Nx.not_equal(0) do
        i = i + 1

        {key, larvae, to_settle} = shuffle_together(key, larvae, to_settle)

        fit_new = fitness_fn.(larvae |> Nx.vectorize(:r)) |> Nx.devectorize()

        fit_old =
          fitness_fn.(grid_values |> Nx.vectorize(:r)) |> Nx.devectorize()

        settled = to_settle &&& (~~~grid_alive ||| fit_new > fit_old)
        grid_alive = grid_alive ||| settled

        settled_with_dim =
          settled
          |> Nx.reshape({:auto, 1})
          |> Nx.broadcast(grid_values |> Nx.shape())

        grid_values = Nx.select(settled_with_dim, larvae, grid_values)
        to_settle = Nx.bitwise_xor(to_settle, settled)

        {key, grid_values, grid_alive, larvae, to_settle, i}
      end

    {key, grid_values, grid_alive}
  end

  defn duplication(grid_values, opts \\ []) do
    n = opts[:n]
    fitness_fn = opts[:fitness_fn]
    fit = fitness_fn.(grid_values |> Nx.vectorize(:r)) |> Nx.devectorize()
    {_val, ind} = Nx.top_k(fit, k: n)
    Nx.gather(grid_values, ind |> Nx.reshape({:auto, 1}))
  end

  # Note: doesn't respect the % chance of death. Always depredates.
  defn depredation(grid_values, grid_alive, opts \\ []) do
    n = opts[:n]
    fitness_fn = opts[:fitness_fn]
    fit = fitness_fn.(grid_values |> Nx.vectorize(:r)) |> Nx.devectorize()

    {_val, ind} = Nx.top_k(-fit, k: n)
    ind = ind |> Nx.reshape({:auto, 1})
    updates = Nx.broadcast(0, ind |> Nx.flatten() |> Nx.shape())

    Nx.indexed_put(
      grid_alive,
      ind,
      updates
    )
  end

  # idea: select alive ones and rest fill up with 0s (or maybe random vals in domain), and just don't care
  defn step(key, grid_values, grid_alive, opts \\ []) do
    opts = keyword!(opts, [:reef])
    reef = opts[:reef]
    {shuffled, key} = Nx.Random.shuffle(key, grid_values)
    {broadcasters, brooders} = shuffled |> Nx.split(reef.n_broadcast)

    {key, broadcasters} = crossover(key, broadcasters)
    {key, brooders} = bit_flip(key, brooders)

    {key, grid_values, grid_alive} =
      larvae_settling(
        key,
        grid_values,
        grid_alive,
        Nx.concatenate([broadcasters, brooders]),
        fitness_fn: reef.fitness_fn,
        settling_trials: reef.settling_trials
      )

    duplicates =
      duplication(
        grid_values,
        n: reef.n_duplication,
        fitness_fn: reef.fitness_fn
      )

    {key, grid_values, grid_alive} =
      larvae_settling(
        key,
        grid_values,
        grid_alive,
        duplicates,
        fitness_fn: reef.fitness_fn,
        settling_trials: reef.settling_trials
      )

    grid_alive =
      depredation(
        grid_values,
        grid_alive,
        # Not a typo, it's the same number for simplicity
        n: reef.n_duplication,
        fitness_fn: reef.fitness_fn
      )

    {key, grid_values, grid_alive}
  end

  defn best(grid_values, opts \\ []) do
    fitness_fn = opts[:fitness_fn]
    idx = fitness_fn.(grid_values |> Nx.vectorize(:r)) |> Nx.devectorize() |> Nx.argmax()
    grid_values[idx]
  end

  defn run(key, grid_values, grid_alive, opts \\ []) do
    opts = keyword!(opts, [:reef])
    reef = opts[:reef]

    while {key, grid_values, grid_alive, i = 0}, i < reef.iters do
      i = i + 1
      {key, grid_values, grid_alive} = step(key, grid_values, grid_alive, reef: reef)
      {key, grid_values, grid_alive, i}
    end
  end
end

defmodule Fitness do
  defn one_max(x) do
    n = Nx.shape(x) |> elem(0)
    x |> Nx.sum() |> Nx.divide(n)
  end
end

{key, grid_values, grid_alive, reef} =
  CoralReef.new(Enum.random(0..2137), &Fitness.one_max(&1), 500, {0, 1}, {0, 1}, 10_000)

Enum.reduce(
  0..100,
  {key, grid_values, grid_alive},
  fn _, {key, grid_values, grid_alive} ->
    CoralReef.step(key, grid_values, grid_alive, reef: reef)
  end
)

res = CoralReef.best(grid_values, fitness_fn: &Fitness.one_max(&1))
Fitness.one_max(res)
```

```elixir
t = Nx.iota({10, 6})

n_crossover_points = t |> Nx.shape() |> elem(1) |> div(2)
dim = Nx.shape(t) |> elem(1)

{crossover_points, key} =
  Nx.Random.randint(key, 0, dim, shape: {n_crossover_points})

# crossover_points =
#   crossover_points
#   |> Nx.reshape({:auto, 1})
#   |> Nx.broadcast({n_crossover_points, 2})
#   |> Nx.reshape({:auto, 1})
#   |> Nx.broadcast(Nx.shape(t))

# t_swap =
#   t
#   |> Nx.reshape({:auto, 2, dim})
#   |> Nx.reverse(axes: [1])
#   |> Nx.reshape({:auto, dim})

# indexing = Nx.iota(t |> Nx.shape(), axis: 1)

# {
#   key,
#   Nx.select(Nx.less(indexing, crossover_points), t, t_swap)
# }
```
